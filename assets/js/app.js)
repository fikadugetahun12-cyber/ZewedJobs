// ============================================
// PWA MAIN APPLICATION SCRIPT
// Core functionality and utilities
// ============================================

'use strict';

// Configuration
const CONFIG = {
  APP_NAME: 'My PWA',
  VERSION: '1.0.0',
  API_BASE_URL: '/api',
  CACHE_DURATION: 24 * 60 * 60 * 1000, // 24 hours
  OFFLINE_RETRY_INTERVAL: 5000, // 5 seconds
  MAX_OFFLINE_ITEMS: 100,
  NOTIFICATION_TIMEOUT: 5000 // 5 seconds
};

// State Management
const AppState = {
  isOnline: navigator.onLine,
  isInstalled: window.matchMedia('(display-mode: standalone)').matches,
  isServiceWorkerActive: false,
  pendingSyncs: [],
  userPreferences: {
    darkMode: window.matchMedia('(prefers-color-scheme: dark)').matches,
    notifications: false,
    offlineMode: true
  },
  currentPage: 'home',
  loading: false,
  error: null,
  data: {}
};

// DOM Elements Cache
const DOM = {
  appContainer: document.getElementById('app'),
  installButton: document.getElementById('installButton'),
  onlineStatus: document.getElementById('onlineStatus'),
  mainContent: document.querySelector('main'),
  header: document.querySelector('header'),
  footer: document.querySelector('footer')
};

// ============================================
// INITIALIZATION
// ============================================

document.addEventListener('DOMContentLoaded', () => {
  console.log(`${CONFIG.APP_NAME} v${CONFIG.VERSION} initializing...`);
  
  initializeApp();
  setupEventListeners();
  checkConnectivity();
  loadUserPreferences();
  registerServiceWorker();
  setupPeriodicSync();
  initializeOfflineStorage();
  checkForUpdates();
  
  console.log('App initialized successfully');
});

// ============================================
// CORE FUNCTIONS
// ============================================

function initializeApp() {
  // Set app version in footer
  const versionElement = document.querySelector('.app-version');
  if (versionElement) {
    versionElement.textContent = `v${CONFIG.VERSION}`;
  }
  
  // Apply user preferences
  applyUserPreferences();
  
  // Set up router for SPA navigation
  setupRouter();
  
  // Initialize UI components
  initializeUIComponents();
}

function setupEventListeners() {
  // Online/offline detection
  window.addEventListener('online', handleOnline);
  window.addEventListener('offline', handleOffline);
  
  // Before install prompt
  window.addEventListener('beforeinstallprompt', handleInstallPrompt);
  
  // App installed detection
  window.addEventListener('appinstalled', handleAppInstalled);
  
  // Visibility change (tab switching)
  document.addEventListener('visibilitychange', handleVisibilityChange);
  
  // Resize events
  window.addEventListener('resize', debounce(handleResize, 250));
  
  // Service Worker messages
  navigator.serviceWorker?.addEventListener('message', handleServiceWorkerMessage);
  
  // Network status
  if (navigator.connection) {
    navigator.connection.addEventListener('change', handleConnectionChange);
  }
}

// ============================================
// SERVICE WORKER MANAGEMENT
// ============================================

function registerServiceWorker() {
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('/sw.js')
      .then(registration => {
        console.log('Service Worker registered:', registration);
        AppState.isServiceWorkerActive = true;
        
        // Check for updates
        registration.addEventListener('updatefound', () => {
          const newWorker = registration.installing;
          newWorker.addEventListener('statechange', () => {
            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
              showUpdateNotification();
            }
          });
        });
        
        // Track service worker state
        trackServiceWorkerState(registration);
      })
      .catch(error => {
        console.error('Service Worker registration failed:', error);
        showToast('Service Worker registration failed', 'error');
      });
  }
}

function trackServiceWorkerState(registration) {
  if (registration.installing) {
    console.log('Service Worker installing');
  } else if (registration.waiting) {
    console.log('Service Worker installed');
  } else if (registration.active) {
    console.log('Service Worker active');
  }
}

function sendMessageToServiceWorker(message) {
  if (navigator.serviceWorker?.controller) {
    navigator.serviceWorker.controller.postMessage(message);
  }
}

function handleServiceWorkerMessage(event) {
  const { type, data } = event.data;
  
  switch (type) {
    case 'SW_ACTIVATED':
      console.log('Service Worker activated:', data.version);
      break;
      
    case 'CONTENT_UPDATED':
      console.log('New content available:', data);
      showToast('New content available', 'info');
      break;
      
    case 'SYNC_COMPLETE':
      console.log('Background sync complete:', data);
      if (data.success) {
        showToast('Changes synced successfully', 'success');
      }
      break;
  }
}

// ============================================
// OFFLINE FUNCTIONALITY
// ============================================

function initializeOfflineStorage() {
  // Initialize IndexedDB for offline storage
  if (!AppState.userPreferences.offlineMode) return;
  
  const request = indexedDB.open('pwa-storage', 1);
  
  request.onerror = (event) => {
    console.error('IndexedDB initialization failed:', event.target.error);
  };
  
  request.onsuccess = (event) => {
    console.log('IndexedDB initialized successfully');
  };
  
  request.onupgradeneeded = (event) => {
    const db = event.target.result;
    
    // Create object stores
    if (!db.objectStoreNames.contains('offlineData')) {
      const store = db.createObjectStore('offlineData', { keyPath: 'id' });
      store.createIndex('timestamp', 'timestamp');
      store.createIndex('type', 'type');
    }
    
    if (!db.objectStoreNames.contains('syncQueue')) {
      const store = db.createObjectStore('syncQueue', { keyPath: 'id', autoIncrement: true });
      store.createIndex('status', 'status');
      store.createIndex('timestamp', 'timestamp');
    }
  };
}

async function saveOfflineData(key, data) {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open('pwa-storage', 1);
    
    request.onsuccess = (event) => {
      const db = event.target.result;
      const transaction = db.transaction(['offlineData'], 'readwrite');
      const store = transaction.objectStore('offlineData');
      
      const item = {
        id: key,
        data: data,
        timestamp: Date.now(),
        type: typeof data
      };
      
      const request = store.put(item);
      
      request.onsuccess = () => resolve(true);
      request.onerror = (error) => reject(error);
    };
    
    request.onerror = (error) => reject(error);
  });
}

async function getOfflineData(key) {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open('pwa-storage', 1);
    
    request.onsuccess = (event) => {
      const db = event.target.result;
      const transaction = db.transaction(['offlineData'], 'readonly');
      const store = transaction.objectStore('offlineData');
      
      const request = store.get(key);
      
      request.onsuccess = () => resolve(request.result?.data || null);
      request.onerror = (error) => reject(error);
    };
    
    request.onerror = (error) => reject(error);
  });
}

async function queueForSync(data) {
  if (!AppState.isOnline) {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open('pwa-storage', 1);
      
      request.onsuccess = (event) => {
        const db = event.target.result;
        const transaction = db.transaction(['syncQueue'], 'readwrite');
        const store = transaction.objectStore('syncQueue');
        
        const item = {
          data: data,
          timestamp: Date.now(),
          status: 'pending',
          attempts: 0
        };
        
        const request = store.add(item);
        
        request.onsuccess = () => {
          AppState.pendingSyncs.push(item);
          resolve(true);
          
          // Register background sync
          if ('sync' in navigator.serviceWorker) {
            navigator.serviceWorker.ready.then(registration => {
              registration.sync.register('sync-data');
            });
          }
        };
        
        request.onerror = (error) => reject(error);
      };
      
      request.onerror = (error) => reject(error);
    });
  }
  
  return syncData(data);
}

// ============================================
// NETWORK & CONNECTIVITY
// ============================================

function checkConnectivity() {
  AppState.isOnline = navigator.onLine;
  updateOnlineStatus();
  
  if (!AppState.isOnline) {
    showOfflineMode();
  }
}

function handleOnline() {
  AppState.isOnline = true;
  updateOnlineStatus();
  showToast('Back online', 'success');
  
  // Process pending syncs
  processPendingSyncs();
  
  // Sync data
  syncPendingData();
}

function handleOffline() {
  AppState.isOnline = false;
  updateOnlineStatus();
  showToast('You are offline', 'warning');
  showOfflineMode();
}

function handleConnectionChange() {
  if (navigator.connection) {
    const connection = navigator.connection;
    const effectiveType = connection.effectiveType;
    const downlink = connection.downlink;
    const rtt = connection.rtt;
    
    console.log(`Connection changed: ${effectiveType}, ${downlink}Mbps, ${rtt}ms`);
    
    // Adjust app behavior based on connection
    if (effectiveType === 'slow-2
